import java.util.*;
class MyQueue {
    // using 2 stacks
    LinkedList<Integer> s1;
    LinkedList<Integer> s2;
    public MyQueue() {
        s1 = new LinkedList<>();
        s2 = new LinkedList<>();
    }

    public void offer(int val) { // add a new element to the back of the queue
        // first, we move all elements from s1 to s2
        // s1 = [1, 2, 3]
        while (!s1.isEmpty()) {
            s2.push(s1.pop());
        }
        // s2 = [3, 2, 1]
        s1.push(val);
        // s1 = [4]
        // move all elements from s2 to s1
        while (!s2.isEmpty()) {
            s1.push(s2.pop());
        }
        // s1 = [4, 3, 2, 1]
    }

    public int poll() { // rmv the front element from the queue
        return s1.pop();
    }

    public int peekFirst() { // return the front element of the queue, not removed
        return s1.peekFirst();
    }

    public boolean isEmpty() {
        return s1.isEmpty();
    }

}

class MyStack {
    // using 2 queues
    LinkedList<Integer> q1;
    LinkedList<Integer> q2;
    public MyStack() {
        q1 = new LinkedList<>();
        q2 = new LinkedList<>();
    }

    // push
    public void push(int x) {
        // move all elements from q1 to q2
        while (!q1.isEmpty()) {
            q2.offer(q1.poll());
        }
        // then move x to q1
        q1.offer(x);
        // now we move all elements back to q1
        while (!q2.isEmpty()) {
            q1.offer(q2.poll());
        }
    }

    // pop
    public int pop() {
        return q1.pollFirst(); // peekLast, peekFirst
    }

    // top
    public int top() {
        return q1.peekFirst();
    }

    // isEmpty()
    public boolean empty() {
        return q1.isEmpty();
    }

}
public class Main {
    public static void main(String[] args) {
        // now let's do a couple tests to see if our stack follows the LIFO rules
        // MyStack stack = new MyStack();
        // stack.push(1);
        // stack.push(2);
        // stack.push(3);
        // stack.push(4);
        // stack.pop(); // remove 4
        // stack.pop(); 
        // stack.pop(); 
        // stack.pop(); 
        MyQueue queue = new MyQueue();
        queue.offer(0);
        queue.offer(1);
        queue.offer(2);
        queue.poll(); // 0 is removed
        queue.poll(); // 1 is removed
        // System.out.println(queue.peekFirst());
        // how do we implement a stack/queue from scratch? 
        // could we use ListNode? 
        // System.out.println(longestValid_1("((()()())"));
        // int[] nums = {1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3};
        // int[] res = topKFreq(nums, 2);
        // for (int i : res) {
        //     System.out.println(i);
        // }
        String s = "abc";
        String s1 = "bcd";
        System.out.println(s.compareTo(s1));
    }
    
    public static int[] topKFreq(int[] nums, int k) {
        // we need a data structure to store the freqs of each ints
        // nums = [1, 1, 1, 2, 2, 2, 3]
        Map<Integer, Integer> map = new HashMap<>();
        for (int i : nums) {
            map.put(i, map.getOrDefault(i, 0) + 1);
        }
        // we need another data structure to rank the freqs of each ints
        // clearly we need a max-heap
        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> map.get(b) - map.get(a));
        // PriorityQueue<String> pq = new PriorityQueue<>((a, b) -> String.compareTo(a, b));
        // PriorityQueue<Integer> pq = new PriorityQueue<>(); // by default, this is a min-heap 
        // Comparator<? super Integer> comparator -> 1, 0, -1

        for (int i : map.keySet()) { // keySet() method return , keySet() = {1, 2, 3}
            pq.offer(i);
        }
        // initialize the result array
        int[] res = new int[k];
        int idx = 0;
        while (idx < k) {
            res[idx] = pq.poll();
            idx++;
        }
        return res;
    }
}
    // // public static int longestValid_1(String s) {
    // //     // s = "())()"
    // //     // find a place holder 
    // //     int res = 0;
    // //     LinkedList<Integer> stack = new LinkedList<>();
    // //     stack.push(-1); // just like dummy node in linked list
    // //     // note that we need to store the indexes
    // //     for (int i = 0; i < s.length(); i++) {
    // //         char curr = s.charAt(i);
    // //         // 1st case, when we meet "("
    // //         if (curr == '(') {
    // //             stack.push(i);
    // //         } else if (stack.peek() != -1 && s.charAt(stack.peek()) == '(') { // the idx on top of the stack is '('
    // //             // say we have s = "))()()"
    // //             stack.pop(); 
    // //             // curr max length
    // //             int currMax = i - (stack.isEmpty() ? -1 : stack.peek());
    // //             // update max length
    // //             res = Math.max(res, currMax);
    // //         } // very important! We will start to find a potentially new longer result
    // //         else {
    // //             stack.push(i); // push the idx of ')'
    // //         }
    // //     }
    // //     return res;
    // // }

    // public static int longestValid(String s) {
    //     // s = "())()"
    //     // find a place holder 
    //     // stack.push(-1); // dummy node
    //     int res = 0;
    //     LinkedList<Integer> stack = new LinkedList<>();
    //     // note that we need to store the indexes
    //     for (int i = 0; i < s.length(); i++) {
    //         char curr = s.charAt(i);
    //         // 1st case, when we meet "("
    //         if (curr == '(') {
    //             stack.push(i);
    //         } else if (!stack.isEmpty() && s.charAt(stack.peek()) == '(') { // the idx on top of the stack is '('
    //             // say we have s = "))()()"
    //             stack.pop(); 
    //             // curr max length
    //             int currMax = i - (stack.isEmpty() ? -1 : stack.peek());
    //             // update max length
    //             res = Math.max(res, currMax);
    //         } // very important! We will start to find a potentially new longer result
    //         else {
    //             stack.push(i); // push the idx of ')'
    //         }
    //     }
    //     return res;
    // }

    // public static boolean isValid(String s) {
    //     // we will use a stack
    //     LinkedList<Character> stack = new LinkedList<>();
    //     // toCharArray() is a built-in Java function
    //     // s = "abc", s.toCharArray() = ['a', 'b', 'c']
    //     // optimize code
    //     for (char c : s.toCharArray()) { 
    //         if (c == ')') {
    //             if (stack.isEmpty() || stack.peek() != '(') {
    //                 return false;
    //             }
    //             stack.pop();
    //         } else if (c == ']') {
    //             if (stack.isEmpty() || stack.peek() != '[') {
    //                 return false;
    //             }
    //             stack.pop();
    //         } else if (c == '}') {
    //             if (stack.isEmpty() || stack.peek() != '{') {
    //                 return false;
    //             }
    //             stack.pop();
    //         } else {
    //             stack.push(c);
    //         }
    //     }
    //     return stack.isEmpty(); // note that we might have non-zero number of '('s
    // }
